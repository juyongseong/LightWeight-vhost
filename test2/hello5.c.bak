/********************************************************
********함수가 시작되고 종료되기 까지의 시간 측정********
********************************************************/
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
//#include <stdlib.h>
#include <linux/delay.h>
#include <linux/time.h>
#include <linux/string.h>

struct timespec start_point, end_point;
int sec;
long nsec;
#define MAX_FUNC 20					//허용가능한 함수의 개수
int fperf_num=0;					//현재 함수의 개수

struct fperf {
	const char* str;
	struct timespec start_point, end_point;
	int sec;					//아직 미사용 총합?
	long nsec;					//"
};

struct fperf fperf_arr[MAX_FUNC];			//배열대신 맵이나 벡터등을 사용할수 있을까?(속도측면,,)

extern void fperf_start(const char * str) {
	int i;
	bool ishaving = false;
	for(i=0; i<fperf_num; i++) {			//배열에 포함되어있는지 확인
		if(strcmp(fperf_arr[i].str, str)==0) {	//함수이름 비교
			ishaving = true;
			break;
		}
	}
	if(!ishaving) {					//등록된 함수가 없다면 추가
		fperf_num++;
		fperf_arr[fperf_num-1].str = str; 
		getnstimeofday(&(fperf_arr[fperf_num-1].start_point));
	} else {
		getnstimeofday(&(fperf_arr[i].start_point));
	}
	//getnstimeofday(&start_point);
}

extern void fperf_end(const char * str) {
	int i, sec;
	long nsec;
	struct fperf *fpp=NULL;
	for(i=0; i<fperf_num; ++i) {
		if(strcmp(fperf_arr[i].str, str)==0) fpp = &fperf_arr[i];
	}
	if(fpp != NULL) {				//널포인터가 아니라면 => 등록된 함수라면
		getnstimeofday(&(fpp->end_point));
		sec = fpp->end_point.tv_sec - fpp->start_point.tv_sec;
        	nsec = fpp->end_point.tv_nsec - fpp->start_point.tv_nsec;
        	if(sec!=0 && nsec < 0)
                	        nsec = 1000000000 - fpp->start_point.tv_nsec + fpp->end_point.tv_nsec;
        	printk("%s %d.%09ld\n",str, sec, nsec);
	}
	/*
	getnstimeofday(&end_point);
        sec = end_point.tv_sec - start_point.tv_sec;
        nsec = end_point.tv_nsec - start_point.tv_nsec;
        if(sec!=0 && nsec < 0)
                        nsec = 1000000000 - start_point.tv_nsec + end_point.tv_nsec;
        printk("%s %d.%09ld\n",str, sec, nsec);
	*/
}
extern void f1(void) {
	fperf_start(__func__);
        msleep(20);
	fperf_end(__func__);
}

extern void f2(void) {
	fperf_start(__func__);
        msleep(10);
	fperf_end(__func__);
}
extern void f3(void) {
	fperf_start(__func__);
	msleep(1);
	fperf_end(__func__);
}
extern void f11(void) {
        fperf_start(__func__);
        msleep(20);
        fperf_end(__func__);
}

extern void f22(void) {
        fperf_start(__func__);
        msleep(10);
	f11();
        fperf_end(__func__);
}
extern void f33(void) {
        fperf_start(__func__);
        msleep(1);
	f22();
        fperf_end(__func__);
}

static int __init init_hello(void){
        printk(KERN_ALERT "Hello, kernel!\n");
	printk(KERN_ALERT "test1\n");
	f1();
	f2();
	f3();
	printk(KERN_ALERT "test2\n");
	f33();
	return 0;
}

static void __exit exit_hello(void){
        printk(KERN_ALERT "Good-bye, kernel!\n");
}

module_init(init_hello);
module_exit(exit_hello);
MODULE_LICENSE("GPL");
